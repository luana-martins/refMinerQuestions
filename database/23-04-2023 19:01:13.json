{"rows":[["4/20/2023 21:21:52","Yes","Tocantins, Brazil","Full master's","Computer science","Academy","Federal Institute of Tocantins",">= 1 year and < 5 years","eclipse.org/jgit, github-api.kohsuke.org",">= 1 year and < 5 years","2","IDE support","Iintellij IDEA","3","Automated tool support","JNose","5383","junit/framework/TestCase.java","148","6","Add Assert Argument, Replace NOT operator, Split Conditional Statement in Assertions","Split Conditional Statement in Assertions","3","Replace NOT operator, Split Conditional Statement in Assertions","src/test/java/junit/samples/ListTest.java","the speed of finding testsmells in the refactorings that occurred","does not have a graphical interface","create a GUI, and increase the number of testsmells that can be detected.","6","6","6","6","6","6","5","5","5","6","4","5","5","6","tassiovirginio@gmail.com"],["4/21/2023 17:45:26","Yes","Itabuna, Bahia, Brazil","Full master's","Computer science","Industry","I'm a freelancer.","< 1 year","-",">= 1 year and < 5 years","4","IDE support","VSCode","2","IDE support","VSCode","5383","junit/framework/TestCase.java","148","6","Add Assert Argument, Replace NOT operator, Split Conditional Statement in Assertions","Split Conditional Statement in Assertions","3","Replace NOT operator, Split Conditional Statement in Assertions","src/test/java/junit/samples/ListTest.java","The main advantage is the automation, so that the developer doesn't need to waste too much time refactoring manually the code.","It's difficult to find the refactorings found in the JSON.","One improvement could be including more info inside the JSON. For example, including the total count that appear in the terminal, also including a resume of the types of refactorings that were found, so that when start reading the JSON, the user will already know all the refactoring types found, then will be able to search in all the commits where this refactoring type was found.  I could be interesting to have other file formats than only JSON. Maybe in format of text, or markdown, so the user can understand and locate faster all the refactorings found.  Also, would be interesting if, besides showing what was the type of refactoring, also show a better description and also a recommendation of how to fix it, even including an external link of some documentation about this type of refactoring, so the user can understand more about it.","6","6","6","6","6","6","6","6","5","6","6","6","6","6","levyssantiago@gmail.com"],["4/22/2023 12:45:00","Yes","Vietri Sul Mare, Salerno, Italy","Master's Degree student","Computer science","Academy","University of Salerno","< 1 year","PyDriller, PyGitHub",">= 1 year and < 5 years","3","Manually","","3","Manually","","5383","junit/framework/TestCase.java","148","6","Split Conditional Statement in Assertions, Add Assert Argument, Replace NOT operator","Split Conditional Statement in Assertions","3","Split Conditional Statement in Assertions, Replace NOT operator","src/test/java/junit/samples/ListTest.java","Considering that my experience in test smells mining is limited to this survey, i think that the json output provided by RefactoringMiner is well structured and easy to analyze. Also the possibility to mine only test classes refactoring is a great feature, considering that the original tool was meant for general class refactoring purposes. Beyond that, i believe that the main advantage of using those kinds of tools, consists in the possibility to conduct test smells detection analysis considering the evolution of the sourse code. By exploiting the possibility to mine test refactoring, i thank that specific large scale analysis on the evolution of specific tests smells are easly to conduct by using those kinds of approaches. ","Considering that the RefactoringMiner tool was born for General Java classes Refactoring mining, the main disadvantage consists in the limited kinds of Test Smells that this specific tool is able to detect. I'don't know how many Test Smells types are considered to develope the tool extention, btw there were several different kinds of test smells to consider in order to perform those kinds of analysis.","Cosidering the main disadvantage that i've underline, i think that the main improvement is to develop specific refactoring detection functionalities, to detect different kinds of Test Smells as much as possible. Anther little hint could be to report explicitly the names of the test smells in the JSON output file. I mean, during the execution of the task, it was difficult to me try to understand which kinds of smells the tool detected.  It would have been easier find explicit labels like \"assertion roulette refactoring\" or something like this.","6","5","6","4","6","6","6","4","3","6","5","5","4","5","carferrara@unisa.it"],["4/22/2023 13:05:57","Yes","Salerno, Italy","PhD student","Computer science","Academy","University of Salerno",">= 1 year and < 5 years","GitHub API",">= 1 year and < 5 years","3","Manually","","2","","","5383","junit/framework/TestCase.java","148","6","Split Conditional Statement in Assertions, Replace NOT operator, Add Assert Argument","Split Conditional Statement in Assertions","3","Split Conditional Statement in Assertions, Replace NOT operator","src/test/java/junit/samples/ListTest.java","The tool analyze the project and gives you tha class with the smell. In this way, you can filter you analysis for test smells detection","I don't know what are the threshold and if the tool is customizable","","5","5","6","5","5","5","6","4","6","6","5","5","4","5",""],["4/22/2023 13:07:11","Yes","Salerno, Italy","PhD student","Computer science","Academy","University of Salerno",">= 1 year and < 5 years","GitHub APis",">= 1 year and < 5 years","3","Manually","","1","","","5383","src/test/java/org/junit/internal/AllInternalTests.java","148","6","Replace NOT operator, Split Conditional Statement in Assertions, Add Assert Argument","Split Conditional Statement in Assertions","3","Replace NOT operator, Split Conditional Statement in Assertions","src/test/java/junit/samples/ListTest.java","The possibility to detect test smell in a small time","I would like to use a \"plug and play\" solution, without configure Java_path environment","I suggest to you implement a configuration script or a docker container","4","4","3","4","4","4","3","4","4","4","4","5","5","6",""],["4/22/2023 15:49:25","Yes","Salerno, Italy","PhD student","Computer engineering","Academy","University of Salerno",">= 1 year and < 5 years","PyDriller, GitPython, JGit, CVE-Search, GitHub API, SOTorrent, Wayback Machine",">= 1 year and < 5 years","4","Manually","IntelliJ Idea (sometimes), VSCode (rarely)","1","","","5383","junit/framework/TestCase.java","148","6","Replace NOT operator, Add Assert Argument, Split Conditional Statement in Assertions","Split Conditional Statement in Assertions","3","Split Conditional Statement in Assertions, Replace NOT operator","src/test/java/junit/samples/ListTest.java","Detecting test refactorings is a precious information. The extension relies on RefactoringMiner itself, so it I guess there are no special points to highlight. Maybe the fact that it's possible to not detect production refactorings is a good think to relieve the analyses.","Exploring the output file is painful, as one is forced to open a large (formatted) JSON file. It's not possible to track its progress (i.e. how many commits it has analyzed and an estimate of the remaining time). Yet, it's not the problem of this extension, but of the base tool. Regarding the extension alone, I think the \"mode\" (-m) option has an unusual syntax, I'd have preferred something like \"--mode=T\". ","Add filter mechanisms (i.e., select the exact refactoring to extract) and a more navigable output format, e.g., HTML file.","6","6","4","6","6","6","4","4","4","5","5","4","2","4","eiannone@unisa.it"],["4/22/2023 17:18:15","Yes","Maceió, Alagoas, Brazil","Graduation student","Computer engineering","Academy and industry","UFAL",">= 1 year and < 5 years","GitHub Search API",">= 1 year and < 5 years","3","IDE support","IntelliSense","2","Manually","","5383","junit/framework/TestCase.java","148","6","Add Assert Argument, Split Conditional Statement in Assertions, Replace NOT operator","Split Conditional Statement in Assertions","3","Replace NOT operator, Split Conditional Statement in Assertions","src/test/java/junit/samples/ListTest.java","It may reduce time to locate and analyze Refactorings, since it shows the exact location of the differences and ","You must know how the tool calls each Refactoring. Also, you must trust that the tool's precision has been correctly measured.","I've had some hard time setting the tool, as some instructions were unclear (setting the enviroment variables). Also, it's unclear if the tool works on linux, I've find it slighty confuse to navigate the json, and I dislike having to set a new name for each new analysis. I think a GUI would greatly improve those problems.","6","6","6","6","6","6","3","4","4","4","3","3","4","6","mpat@ic.ufal.br"],["4/23/2023 12:28:07","Yes","Salerno, Campania, Italy","PhD student","Computer science","Academy","University of Salerno",">= 1 year and < 5 years","PyDriller",">= 1 year and < 5 years","4","IDE support","IntelliJ, PyCharm","3","Manually","","5383","junit/framework/TestCase.java","148","6","Replace NOT operator, Split Conditional Statement in Assertions, Add Assert Argument","Split Conditional Statement in Assertions","3","Split Conditional Statement in Assertions, Replace NOT operator","src/test/java/junit/samples/ListTest.java","Undoubtedly, by using this extension, I could be able to improve test suite quality and maintainability","I am not sure about the probability of identifying a false positive. Nevertheless, I see no major disadvantages to the tool use.","","5","5","5","6","6","6","5","5","4","5","4","5","5","5","slambiase@unisa.it"]],"titles":["Timestamp","I declare that I understand the objectives, risks and benefits of my participation in the research ","1. Where are you from?","2. What's your degree level? ","3. What is your latest course?","4. Where are you currently working in?  ","5. What institution do you study or what company do you work for?","6. What is your experience with software repositories mining (in years)?  ","7. What tools or APIs do you use to perform repository mining?","8. What is your experience with code refactoring (in years)?  ","9. How often do you perform refactorings in the production code?","10. How do you usually perform refactorings in the production code?","11. If you use any automated tools or IDE to support refactorings in the code, please specify which ones you use.","12. How often do you perform refactorings on the test code?","13. How do you usually perform refactorings in the test code?","14. If you use any automated tools or IDE to support refactorings in the test code, please specify which ones you use.","15. How many refactorings did the tool report in total?","16. What is the test filepath where the  “Add Assert Argument” refactoring was applied?","17. What is the line number where the “Add Assert Argument” refactoring was applied?","18. How many test refactorings did the tool report in total?","19. Which are the test refactorings reported by the tool? ","20. Which is the test refactoring with the highest number of occurrences?","21. How many test refactorings did the tool report?","22. Which are the test refactorings reported by the tool? ","23. What is the test filepath where the test refactoring was applied?","24. What are the advantages of using the RefactoringMiner tool's extension to mine test smells?","25. What are the disadvantages of using the RefactoringMiner tool's extension to mine test smells?","26. What would you suggest to improve the RefactoringMiner tools' extension?","27. Regarding the perceived usefulness (U) of the RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [U1. Using the RefactoringMiner tool in my job, I would be able to mine test refactorings more quickly.]","27. Regarding the perceived usefulness (U) of the RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [U2. Using the RefactoringMiner tool would improve my performance on mining test refactorings.]","27. Regarding the perceived usefulness (U) of the RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [U3. Using the RefactoringMiner tool for mining test refactorings would increase my productivity.]","27. Regarding the perceived usefulness (U) of the RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [U4. Using the RefactoringMiner tool would enhance my effectiveness on mining test refactorings.]","27. Regarding the perceived usefulness (U) of the RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [U5. Using the RefactoringMiner tool would make it easier to mine test refactorings]","27. Regarding the perceived usefulness (U) of the RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [U6. I would find the RefactoringMiner tool useful to perform mining test refactorings.]","28. Regarding the perceived ease of use (E) of the  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [E1. Learning to operate the RefactoringMiner tool would be easy for me.]","28. Regarding the perceived ease of use (E) of the  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [E2. I would find it easy to get the RefactoringMiner tool to do what I want it to do.]","28. Regarding the perceived ease of use (E) of the  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [E3. My interaction with the RefactoringMiner tool would be clear and understandable]","28. Regarding the perceived ease of use (E) of the  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [E4. It would be easy to become skillful in using the RefactoringMiner tool.]","28. Regarding the perceived ease of use (E) of the  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [E5. It would be easy to remember how to mine test refactorings using the RefactoringMiner tool.]","28. Regarding the perceived ease of use (E) of the  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [E6. I would find the RefactoringMiner tool easy to use.]","29. Regarding the perceived self-predicted future use (S) of  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [S1. Assuming the RefactoringMiner tool is available on my job, I predict that I will use it on a regular basis in the future.]","29. Regarding the perceived self-predicted future use (S) of  RefactoringMiner tool's extension, please rate the items from “Extremely unlikely” (1) to “Extremely likely” (6): [S2. I prefer using the RefactoringMiner tool for mining test refactorings than not using it.]","30. If you would like to follow up with the next steps of this study, please informe your e-mail:"],"language":"en","classifications":["timestamp","openQuestion","cityState","negativeOrList","groupsInAnswer","cityState","negativeOrList","groupsInAnswer","negativeOrList","groupsInAnswer","groupsInAnswer","openQuestion","openQuestion","groupsInAnswer","openQuestion","openQuestion","openQuestion","groupsInAnswer","groupsInAnswer","openQuestion","openQuestion","openQuestion","openQuestion","openQuestion","groupsInAnswer","negativeOrList","negativeOrList","negativeOrList","openQuestion","openQuestion","openQuestion","openQuestion","openQuestion","openQuestion","openQuestion","negativeOrList","openQuestion","openQuestion","openQuestion","openQuestion","openQuestion","openQuestion","groupsInAnswer"]}